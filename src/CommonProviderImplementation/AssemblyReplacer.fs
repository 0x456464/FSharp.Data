// --------------------------------------------------------------------------------------
// Utilities for transforming F# quotations to reference types from different assemblies
// --------------------------------------------------------------------------------------

namespace ProviderImplementation

open System
open System.Collections.Generic
open System.IO
open System.Reflection
open Microsoft.FSharp.Quotations
open Microsoft.FSharp.Quotations.ExprShape
open Microsoft.FSharp.Quotations.Patterns
open Microsoft.FSharp.Reflection
open ProviderImplementation.ProvidedTypes

// ----------------------------------------------------------------------------------------------

[<AutoOpen>]
module internal UncheckedQuotations =

      // The FSharp.Core Expr.NewDelegate operation is overly strict and doesn't allow generation of quotations for delegate
      // creations for cross-targeted FSharp.Core.  This is a hack to allow creation of NewDelegate quotation nodes that re less strict.
      type Microsoft.FSharp.Quotations.Expr with 

          static member NewDelegateUnchecked (ty: Type, vs: Var list, body: Expr) =
              let e : Expr =  List.foldBack (fun v acc -> Expr.Lambda(v,acc)) vs body 
              let qTy = typeof<Microsoft.FSharp.Quotations.Var>.Assembly.GetType("Microsoft.FSharp.Quotations.ExprConstInfo") 
              let newDelegateOp = if qTy = null then null else qTy.GetMethod("NewNewDelegateOp", BindingFlags.Static ||| BindingFlags.Public ||| BindingFlags.NonPublic)
              let pTy = typeof<Microsoft.FSharp.Quotations.Var>.Assembly.GetType("Microsoft.FSharp.Quotations.PatternsModule")
              let mkFE1 = if pTy = null then null else pTy.GetMethod("mkFE1", BindingFlags.Static ||| BindingFlags.Public ||| BindingFlags.NonPublic)
              if newDelegateOp = null || mkFE1 = null then 
                  Expr.NewDelegate(ty, vs,  body)
              else
                  let delOp = newDelegateOp.Invoke(null, [| box ty |])
                  let expr = mkFE1.Invoke(null, [| box delOp; box e |])
                  expr :?> Expr

(*
      let UnionCaseInfoUnchecked (declTy: Type, tag: int) = 
          let uci = typeof<Microsoft.FSharp.Reflection.UnionCaseInfo>
          let mkUci = uci.GetConstructor(BindingFlags.Instance ||| BindingFlags.Public ||| BindingFlags.NonPublic, null, [| typeof<Type>; typeof<int> |], null)
          mkUci.Invoke [| box declTy; box tag |] :?> UnionCaseInfo
*)

//type DT = class end
type TypeRT = { X: Type }
type ExprRT = { X: Expr }
type VarRT = { X: Var }

[<AutoOpen>]
module QUtils = 
    let rawtype (t:TypeRT) = t.X
    let rawexpr (t:ExprRT) = t.X
    let rawvar (t:VarRT) = t.X
    let rttype (t:Type) : TypeRT = { X = t }
    let rtexpr (t:Expr) : ExprRT = { X = t }
    let rtvar (t:Var) : VarRT = { X = t }
    let VarRT (nm,ty) = Var(nm, rawtype ty) |> rtvar

/// When we split a type provider into a runtime assembly and a design time assembly, we can no longer 
/// use quotations directly, because they will reference the wrong types. AssemblyReplacer fixes that 
/// by transforming the expressions generated by the quotations to have the right types. On all 
/// expressions  that we provide to InvokeCode and GetterCode of ProvidedMethod, ProvidedConstructor,
/// and ProvidedProperty, instead of (fun args -> <@@ doSomethingWith(%%args) @@>), we should use 
/// (fun args -> let args = replacer.ToDesignTime args in replacer.ToRuntime <@@ doSomethingWith(%%args) @@>)
/// When creating the Provided* type, we have to always specify the runtime type, and when it invokes
/// the function provided to InvokeCode and GetterCode, we to first transform the argument expressions
/// to the design time types, so we can splice it in the quotation, and then after that we have to convert
/// it back to the runtime type. A further complication arises because Expr.Var's have reference equality, so
/// when can't just create new Expr.Var's with the same variable name and a different type. When transforming
/// them from runtime to design time we keep them in a dictionary, so that when we convert them back to runtime
/// we can return the exact same instance that was provided to us initially.
/// Another limitation (not only of this method, but in general with type providers) is that we can never use 
/// expressions that use F# functions as parameters or return values, we always have to use felegates instead.
type AssemblyReplacer(asmMappingsFwd) =

  /// Creates an AssemblyReplacer with the provided list of designTimeAssembly*runtimeAssembly mappings
  /// Should always receive the current running assembly paired with the RuntimeAssembly from TypeProviderConfig,
  /// and in case we're targetting a different .Net framework profile, the FSharp.Core version referenced
  /// by the current assembly paired with the FSharp.Core version referenced by the runtime assembly
  let asmMappingsReversed = asmMappingsFwd |> List.map (fun (a, b) -> b, a)
  let varTable = Dictionary<Var, Var>()
  let typeCache = Dictionary<(Assembly * Type), Type>()
  let assembliesCache = Dictionary<Type, Assembly[]>()


  // We use a list for asmMappings because the Assembly type is not an IComparable and can't be stored in a map
  // In the originalsAsms list the first assembly has to be the assembly of the outer type
  // We use a lazy type for the original to avoid doing unneeded work in the discriminated unions case
  let replaceLazy asmMappings (lazyOriginal : 'a Lazy, originalAsms) f =
    let sameAsm (a1:Assembly) (a2:Assembly) = (a1 = a2 )
    let toAsmCandidates = 
      asmMappings
      |> List.choose (fun (fromAsm, toAsm) ->
        if originalAsms |> Array.exists (sameAsm fromAsm) && sameAsm fromAsm originalAsms.[0] then
          // if we found a replacement for the outer type assembly, return it
          Some toAsm
        else
          None)
    let toAsmCandidates =
      match toAsmCandidates with
      | [] ->
          asmMappings
          |> List.tryPick (fun (fromAsm, _) -> 
            if originalAsms |> Array.exists (sameAsm fromAsm) then
              // if we found a replacement for a inner type, just return the original
              // assembly of the outer type to signal that it needs to be visited, but it
              // doesn't make sense to replace it with toAsm
              Some [ originalAsms.[0] ]
            else
              None)
      | toAsmCandidates -> Some toAsmCandidates
    match toAsmCandidates with
    | None -> lazyOriginal.Value
    | Some toAsmCandidates -> f toAsmCandidates

  let replace asmMappings (original, originalAsms) f =
    replaceLazy asmMappings (lazy original, originalAsms) f

  let fixName (fullName:string) =
        if fullName.StartsWith("FSI_") then 
            // when F# Interactive is the host of the design time assembly,
            // all namespaces are prefixed with FSI_, in the runtime assembly
            // the name won't have that prefix
            fullName.Substring(fullName.IndexOf('.') + 1)
        else 
            fullName

  let rec getTypeDefinition asmCandidates (t:Type) =
    let tryGetTypeFromAssembly (asm:Assembly) =
      match typeCache.TryGetValue((asm, t)) with
      | true, t -> Some t
      | false, _ ->

          let fullName = fixName t.FullName
          let newT = 
            if asm.FullName.StartsWith "FSI-ASSEMBLY" then
              // when F# Interactive is the host of the design time assembly,
              // for each type in the runtime assembly there might be multiple
              // versions (FSI_0001.FullTypeName, FSI_0002.FullTypeName, etc).
              // Get the last one.
              asm.GetTypes() 
              |> Seq.filter (fun t -> (fixName t.FullName) = fullName)
              |> Seq.sortBy (fun t -> t.FullName)
              |> Seq.last
            else
              asm.GetType fullName

          if newT = null then
            None
          else
            typeCache.Add((asm, t), newT)
            Some newT
    match List.choose tryGetTypeFromAssembly asmCandidates with
    | [ t ] -> t
    | _ :: _ -> failwithf "Type '%O' found in multiple locations from %A" t (asmCandidates |> List.map (fun asm -> asm.Location))
    | _ -> failwithf "Type '%O' not found in %A" t (asmCandidates |> List.map (fun asm -> asm.Location))


  and getType asmCandidates (t:Type) asmMappings =
        if t.IsGenericType && not t.IsGenericTypeDefinition then 
            let genericType = t.GetGenericTypeDefinition()
            let newT = getTypeDefinition asmCandidates genericType
            let typeArguments = t.GetGenericArguments() |> Array.map (replaceType asmMappings)
            newT.MakeGenericType(typeArguments)
             
        elif t.IsGenericParameter then t
        elif t.IsArray || t.IsByRef || t.IsPointer then 
            let elemType = t.GetElementType()
            let elemTypeT = getType asmCandidates elemType asmMappings
            if t.IsArray then 
                let rank = t.GetArrayRank()
                if rank = 1 then elemTypeT.MakeArrayType() else elemTypeT.MakeArrayType(t.GetArrayRank())
            elif t.IsByRef then elemTypeT.MakeByRefType()
            else elemTypeT.MakePointerType()

        else 
            getTypeDefinition asmCandidates t

  // there might be multiple assemblies involved in generic types
  and getAssemblies t =
    let rec innerGetAssemblies (t:Type) = seq {
      if t.IsGenericType && not t.IsGenericTypeDefinition then
        yield t.GetGenericTypeDefinition().Assembly
        for t in t.GetGenericArguments() do
          yield! innerGetAssemblies t
      elif t.IsArray || t.IsPointer || t.IsByRef then 
        yield! innerGetAssemblies (t.GetElementType()) 
      elif t :? ProvidedTypeDefinition then
        ()
      else
        yield t.Assembly
      
    }
    match assembliesCache.TryGetValue t with
    | true, asms -> asms
    | false, _ ->
        let asms = t |> innerGetAssemblies |> Seq.distinct |> Seq.toArray
        assembliesCache.Add(t, asms)
        asms

  and replaceType asmMappings (t : Type) =    
    if t :? ProvidedTypeDefinition then t
    else replace asmMappings (t, getAssemblies t) (fun asmCandidates -> getType asmCandidates t asmMappings)

  let replaceProperty asmMappings (p : PropertyInfo) =
    if p :? ProvidedProperty then p
    else replace asmMappings (p, getAssemblies p.DeclaringType) (fun asmCandidates ->
      let t = getType asmCandidates p.DeclaringType asmMappings
      let isStatic = 
        p.CanRead && p.GetGetMethod().IsStatic || 
        p.CanWrite && p.GetSetMethod().IsStatic
      let bindingFlags = 
        BindingFlags.Public ||| BindingFlags.NonPublic ||| 
          (if isStatic then BindingFlags.Static else BindingFlags.Instance)
      let newP = t.GetProperty(p.Name, bindingFlags)
      if newP = null then
        failwithf "Property '%O' of type '%O' not found in %A" p t (asmCandidates |> List.map (fun asm -> asm.Location))
      newP)

  let replaceField asmMappings (f : FieldInfo) =
    if f :? ProvidedField then f
    else replace asmMappings (f, getAssemblies f.DeclaringType) (fun asmCandidates ->
      let t = getType asmCandidates f.DeclaringType asmMappings
      let bindingFlags = 
        (if f.IsPublic then BindingFlags.Public else BindingFlags.NonPublic) ||| 
        (if f.IsStatic then BindingFlags.Static else BindingFlags.Instance)
      let newF = t.GetField(f.Name, bindingFlags)
      if newF = null then
        failwithf "Field '%O' of type '%O' not found in %A" f t (asmCandidates |> List.map (fun asm -> asm.Location))
      newF)
  
  let replaceMethod asmMappings (m : MethodInfo) =
    if m :? ProvidedMethod then m
    else 
      let assemblies = 
        Array.append [| m.DeclaringType |] (m.GetGenericArguments())
        |> Array.collect (getAssemblies)
      replace asmMappings (m, assemblies) (fun asmCandidates ->
        // TODO: this will fail to correctly bind methods in generic types
        let declTyT = getType asmCandidates m.DeclaringType asmMappings
        let mT =
          if m.IsGenericMethod then 
            let genericMethod = m.GetGenericMethodDefinition()
            let parameterTypesT = genericMethod.GetParameters() |> Array.map (fun p -> replaceType asmMappings p.ParameterType) 
            let genericMethodT = declTyT.GetMethod(genericMethod.Name,parameterTypesT)
            if genericMethodT = null then null else
            let typeArgumentsT =  m.GetGenericArguments() |> Array.map (replaceType asmMappings) 
            genericMethodT.MakeGenericMethod(typeArgumentsT)
          else 
            let parameterTypesT = m.GetParameters() |> Array.map (fun p -> replaceType asmMappings p.ParameterType) 
            declTyT.GetMethod(m.Name, parameterTypesT)
        match mT with 
        | null -> failwithf "Method '%O' not found in type '%O' in one of %A" m mT (asmCandidates |> List.map (fun asm -> asm.Location))
        | _ -> mT)

  let replaceConstructor asmMappings (cons : ConstructorInfo) =
    if cons :? ProvidedConstructor then cons
    else replace asmMappings (cons, getAssemblies cons.DeclaringType) (fun asmCandidates ->
      let declTyT = getType asmCandidates cons.DeclaringType asmMappings
      let parameterTypesT = cons.GetParameters() |> Array.map (fun p -> replaceType asmMappings p.ParameterType) 
      let consT = declTyT.GetConstructor(parameterTypesT)
      match consT with 
      | null -> failwithf "Constructor '%O' not found in type '%O' in one of %A" cons declTyT (asmCandidates |> List.map (fun asm -> asm.Location))
      | _ -> consT)

  let replaceVar asmMappings reversePass (v: Var) =
    if v.Type :? ProvidedTypeDefinition then v
    else replace asmMappings (v, getAssemblies v.Type) (fun asmCandidates ->
      let createNewVar() = 
        Var (v.Name, getType asmCandidates v.Type asmMappings, v.IsMutable)
      if reversePass then
        let newVar = createNewVar()
        // store the original var as we'll have to revert to it later
        varTable.Add(newVar, v)
        newVar
      else
        match varTable.TryGetValue v with
        | true, v -> v
        | false, _ -> 
            // It's a variable local to the quotation
            let newVar = createNewVar()
            // store it so we reuse it from now on
            varTable.Add(v, newVar)
            newVar)
  
  let rec replaceExpr asmMappings reversePass quotation =
    let rt = replaceType asmMappings
    let rp = replaceProperty asmMappings
    let rf = replaceField asmMappings
    let rm = replaceMethod asmMappings
    let rc = replaceConstructor asmMappings
    let rv = replaceVar asmMappings reversePass
    let re = replaceExpr asmMappings reversePass
    
    match quotation with
    | Call (obj, m, args) -> 
        let mR = rm m
        let argsR = List.map re args
        match obj with
        | Some obj -> Expr.Call (re obj, mR, argsR)
        | None -> Expr.Call (mR, argsR)
    | PropertyGet (obj, p, indexArgs) -> 
        let pR = rp p
        let indexArgsR = List.map re indexArgs
        match obj with
        | Some obj -> Expr.PropertyGet (re obj, pR, indexArgsR)
        | None -> Expr.PropertyGet (pR, indexArgsR)
    | PropertySet (obj, p, indexArgs, value) -> 
        let pR = rp p
        let indexArgsR = List.map re indexArgs
        match obj with
        | Some obj -> Expr.PropertySet (re obj, pR, re value, indexArgsR)
        | None -> Expr.PropertySet (pR, re value, indexArgsR)
    | NewObject (c, exprs) ->
        let exprsR = List.map re exprs
        Expr.NewObject (rc c, exprsR)
    | Coerce (expr, t) ->
        Expr.Coerce (re expr, rt t)
    | NewArray (t, exprs) ->
        Expr.NewArray (rt t, List.map re exprs)
    | NewTuple (exprs) ->
        Expr.NewTuple (List.map re exprs)
    | TupleGet (expr, i) ->
        Expr.TupleGet (re expr, i)
    | NewDelegate (t, vars, expr) ->
        Expr.NewDelegateUnchecked (rt t, List.map rv vars, re expr)
    | FieldGet (obj, f) -> 
        match obj with
        | Some obj -> Expr.FieldGet (re obj, rf f)
        | None -> Expr.FieldGet (rf f)
    | FieldSet (obj, f, value) -> 
        match obj with
        | Some obj -> Expr.FieldSet (re obj, rf f, re value)
        | None -> Expr.FieldSet (rf f, re value)
    | Let (var, value, body) -> 
        Expr.Let(rv var, re value, re body)
    | ShapeVar v -> 
        Expr.Var (rv v)
    | ShapeLambda _ -> 
        failwith ("It's not possible to create a Lambda when cross targetting to a different FSharp.Core.\n" +
                  "Make sure you're not calling a function with signature A->(B->C) instead of A->B->C (using |> causes this).")
    | ShapeCombination (o, exprs) -> 
        RebuildShapeCombination (o, List.map re exprs)

  /// Gets the equivalent runtime type
  let typeToRuntime (t:Type) = t |> replaceType asmMappingsFwd |> rttype
  /// Gets an equivalent expression with all the types replaced with runtime equivalents
  let exprToRuntime (e:Expr) = e |> replaceExpr asmMappingsFwd false |> rtexpr
  /// Gets an equivalent expression with all the types replaced with designTime equivalents
  let exprToDesignTime (e:ExprRT) = e.X |> replaceExpr asmMappingsReversed true 

  member replacer.ProvidedParameter(paramName, typ) = 
      ProvidedParameter(paramName, typ |> typeToRuntime |> rawtype)

  member replacer.ProvidedProperty(propertyName, typ, getterCode) = 
      ProvidedProperty(propertyName, typ |> typeToRuntime |> rawtype, GetterCode = (List.map (rtexpr >> exprToDesignTime) >> getterCode >> exprToRuntime >> rawexpr))

  member replacer.ProvidedConstructor(parameters, invokeCode: Expr list -> Expr) = 
      ProvidedConstructor(parameters, InvokeCode = (List.map (rtexpr >> exprToDesignTime) >> invokeCode >> exprToRuntime >> rawexpr))

  member replacer.ProvidedMethod(nm, parameters, resultType: Type, isStatic, invokeCode: Expr list -> Expr) = 
      ProvidedMethod(nm, parameters, 
                     resultType |> typeToRuntime |> rawtype , 
                     IsStaticMethod = isStatic, 
                     InvokeCode = (List.map rtexpr >> List.map exprToDesignTime >> invokeCode >> exprToRuntime >> rawexpr))

  member replacer.ProvidedTypeDefinition(nm, baseType: Type, hideObjectMethods, nonNullable) = 
      ProvidedTypeDefinition(nm, Some (baseType |> typeToRuntime |> rawtype), HideObjectMethods = hideObjectMethods, NonNullable = nonNullable)

  member replacer.ProvidedTypeDefinition(asm, ns, typeName, baseType: Type, hideObjectMethods, nonNullable) = 
      ProvidedTypeDefinition(asm, ns, typeName, Some (baseType |> typeToRuntime |> rawtype), HideObjectMethods = hideObjectMethods, NonNullable = nonNullable)


